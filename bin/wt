#!/usr/bin/env bash
# wt — manage isolated git worktrees
#
# Usage:
#   wt <branch>          create worktree and open Claude Code (default)
#   wt c <branch>        create worktree and open Claude Code
#   wt o <branch>        create worktree and open Codex
#   wt rm <branch>       tear down worktree (DB, bucket, git worktree)
#   wt clean             find and delete orphaned DBs, buckets, and worktrees
set -euo pipefail

SB_HOST="127.0.0.1"
SB_PORT="54322"
SB_USER="postgres"
SB_PASS="postgres"

MODE="c"
BRANCH=""

case $# in
  0)
    echo "Usage: wt [c|o|rm|clean] <branch-name>"
    exit 1
    ;;
  1)
    if [ "$1" = "clean" ]; then
      MODE="clean"
    else
      BRANCH="$1"
    fi
    ;;
  2)
    case "$1" in
      c|o) MODE="$1"; BRANCH="$2" ;;
      rm)  MODE="rm"; BRANCH="$2" ;;
      *) echo "Unknown mode '$1'. Use 'c', 'o', 'rm', or 'clean'."; exit 1 ;;
    esac
    ;;
  *)
    echo "Usage: wt [c|o|rm|clean] <branch-name>"
    exit 1
    ;;
esac

if ! git rev-parse --git-dir > /dev/null 2>&1; then
  echo "Error: not a git repository"
  exit 1
fi

REPO_ROOT=$(git rev-parse --show-toplevel)
REPO_NAME=$(basename "$REPO_ROOT")

# ── clean: find and remove orphaned DBs, buckets, and worktrees ──────────────
if [ "$MODE" = "clean" ]; then
  echo "━━━ Cleaning up ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

  # Build set of slugs for all active worktrees (underscore form for DB/bucket)
  ACTIVE_SLUGS=()
  while IFS= read -r line; do
    branch="${line#branch refs/heads/}"
    slug=$(echo "$branch" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/_/g' | sed -E 's/^_|_$//g')
    ACTIVE_SLUGS+=("$slug")
  done < <(git worktree list --porcelain | grep '^branch ')

  # Find all wt_* databases
  ALL_DBS=$(PGPASSWORD="$SB_PASS" psql \
    -h "$SB_HOST" -p "$SB_PORT" -U "$SB_USER" -d postgres \
    -tAc "SELECT datname FROM pg_database WHERE datname LIKE 'wt_%'")

  # Find all all-files-* buckets
  ALL_BUCKETS=$(PGPASSWORD="$SB_PASS" psql \
    -h "$SB_HOST" -p "$SB_PORT" -U "$SB_USER" -d postgres \
    -tAc "SELECT id FROM storage.buckets WHERE id LIKE 'all-files-%'")

  # Find worktrees whose branch has been merged into dev
  STALE_WORKTREES=()
  current_wt=""
  while IFS= read -r line; do
    case "$line" in
      worktree\ *)
        current_wt="${line#worktree }"
        ;;
      branch\ *)
        if [ "$current_wt" != "$REPO_ROOT" ]; then
          branch="${line#branch refs/heads/}"
          if git merge-base --is-ancestor "$branch" dev 2>/dev/null; then
            STALE_WORKTREES+=("$current_wt")
          fi
        fi
        ;;
    esac
  done < <(git worktree list --porcelain)

  # Find branches merged into dev (excluding dev itself and main)
  STALE_BRANCHES=()
  while IFS= read -r b; do
    b="${b#"${b%%[![:space:]]*}"}"  # trim leading whitespace
    b="${b#\* }"                    # strip current branch marker
    [ "$b" = "dev" ] || [ "$b" = "main" ] || STALE_BRANCHES+=("$b")
  done < <(git branch --merged dev 2>/dev/null)

  # Find unregistered sibling dirs
  REGISTERED_DIRS=$(git worktree list --porcelain | grep '^worktree ' | awk '{print $2}')

  ORPHAN_DBS=()
  ORPHAN_BUCKETS=()
  ORPHAN_DIRS=()

  for db in $ALL_DBS; do
    slug="${db#wt_}"
    found=false
    for active in ${ACTIVE_SLUGS[@]+"${ACTIVE_SLUGS[@]}"}; do
      [ "$slug" = "$active" ] && found=true && break
    done
    $found || ORPHAN_DBS+=("$db")
  done

  for bucket in $ALL_BUCKETS; do
    slug="${bucket#all-files-}"
    found=false
    for active in ${ACTIVE_SLUGS[@]+"${ACTIVE_SLUGS[@]}"}; do
      [ "$slug" = "$active" ] && found=true && break
    done
    $found || ORPHAN_BUCKETS+=("$bucket")
  done

  # Check for sibling dirs matching django-* that aren't registered worktrees
  PARENT=$(dirname "$REPO_ROOT")
  for dir in "$PARENT"/"$REPO_NAME"-*/; do
    [ -d "$dir" ] || continue
    dir="${dir%/}"
    if ! echo "$REGISTERED_DIRS" | grep -qF "$dir"; then
      ORPHAN_DIRS+=("$dir")
    fi
  done

  if [ ${#ORPHAN_DBS[@]} -eq 0 ] && [ ${#ORPHAN_BUCKETS[@]} -eq 0 ] && [ ${#ORPHAN_DIRS[@]} -eq 0 ] && [ ${#STALE_WORKTREES[@]} -eq 0 ] && [ ${#STALE_BRANCHES[@]} -eq 0 ]; then
    echo "  Nothing to clean up."
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    exit 0
  fi

  echo ""
  [ ${#ORPHAN_DBS[@]} -gt 0 ]      && printf '  databases : %s\n' "${ORPHAN_DBS[@]}" || true
  [ ${#ORPHAN_BUCKETS[@]} -gt 0 ]  && printf '  buckets   : %s\n' "${ORPHAN_BUCKETS[@]}" || true
  [ ${#ORPHAN_DIRS[@]} -gt 0 ]     && printf '  dirs      : %s\n' "${ORPHAN_DIRS[@]}" || true
  [ ${#STALE_WORKTREES[@]} -gt 0 ] && printf '  worktrees : %s\n' "${STALE_WORKTREES[@]}" || true
  [ ${#STALE_BRANCHES[@]} -gt 0 ] && printf '  branches  : %s\n' "${STALE_BRANCHES[@]}" || true
  echo ""
  read -r -p "Delete all of the above? [yes/N] " confirm
  [[ "$confirm" =~ ^[Yy][Ee][Ss]$ ]] || { echo "Aborted."; exit 0; }

  for db in ${ORPHAN_DBS[@]+"${ORPHAN_DBS[@]}"}; do
    echo "→ Dropping database '$db'..."
    PGPASSWORD="$SB_PASS" psql \
      -h "$SB_HOST" -p "$SB_PORT" -U "$SB_USER" -d postgres \
      -c "DROP DATABASE IF EXISTS \"$db\" WITH (FORCE);" > /dev/null
  done

  for bucket in ${ORPHAN_BUCKETS[@]+"${ORPHAN_BUCKETS[@]}"}; do
    echo "→ Deleting bucket '$bucket'..."
    PGPASSWORD="$SB_PASS" psql \
      -h "$SB_HOST" -p "$SB_PORT" -U "$SB_USER" -d postgres \
      -v ON_ERROR_STOP=0 <<SQL > /dev/null
DELETE FROM storage.objects WHERE bucket_id = '$bucket';
DELETE FROM storage.buckets WHERE id = '$bucket';
SQL
  done

  for dir in ${ORPHAN_DIRS[@]+"${ORPHAN_DIRS[@]}"}; do
    echo "→ Removing directory '$dir'..."
    rm -rf "$dir"
  done

  for wt in ${STALE_WORKTREES[@]+"${STALE_WORKTREES[@]}"}; do
    echo "→ Removing worktree '$wt'..."
    wt_branch=$(cd "$wt" && git branch --show-current)
    if [ -f "$wt/worktree-teardown.sh" ]; then
      (cd "$wt" && bash worktree-teardown.sh)
    fi
    pgrep -f "$wt" | xargs kill 2>/dev/null || true
    git worktree remove --force "$wt"
    echo "→ Deleting branch '$wt_branch'..."
    git branch -d "$wt_branch" 2>/dev/null || true
  done

  for b in ${STALE_BRANCHES[@]+"${STALE_BRANCHES[@]}"}; do
    echo "→ Deleting branch '$b'..."
    git branch -d "$b" 2>/dev/null || true
  done

  echo ""
  echo "━━━ Clean complete ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  exit 0
fi

SLUG=$(echo "$BRANCH" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g' | sed -E 's/^-|-$//g')
WORKTREE_DIR="$(dirname "$REPO_ROOT")/${REPO_NAME}-${SLUG}"

# ── rm: tear down DB/bucket then remove the git worktree ────────────────────
if [ "$MODE" = "rm" ]; then
  # If not found, try stripping repo name prefix (e.g. "django-testtt" → "testtt")
  if [ ! -d "$WORKTREE_DIR" ]; then
    STRIPPED=$(echo "$BRANCH" | sed "s/^${REPO_NAME}-//")
    ALT_SLUG=$(echo "$STRIPPED" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g' | sed -E 's/^-|-$//g')
    ALT_DIR="$(dirname "$REPO_ROOT")/${REPO_NAME}-${ALT_SLUG}"
    if [ -d "$ALT_DIR" ]; then
      WORKTREE_DIR="$ALT_DIR"
    else
      echo "Error: worktree not found at $WORKTREE_DIR"
      exit 1
    fi
  fi

  WT_BRANCH=$(cd "$WORKTREE_DIR" && git branch --show-current)
  WT_SLUG=$(echo "$WT_BRANCH" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/_/g' | sed -E 's/^_|_$//g')

  echo ""
  echo "  worktree : $WORKTREE_DIR"
  echo "  branch   : $WT_BRANCH"
  echo "  database : wt_${WT_SLUG}"
  echo "  bucket   : all-files-${WT_SLUG}"
  echo ""
  read -r -p "Delete all of the above? [yes/N] " confirm
  [[ "$confirm" =~ ^[Yy][Ee][Ss]$ ]] || { echo "Aborted."; exit 0; }

  if [ -f "$WORKTREE_DIR/worktree-teardown.sh" ]; then
    (cd "$WORKTREE_DIR" && bash worktree-teardown.sh)
  fi

  pgrep -f "$WORKTREE_DIR" | xargs kill 2>/dev/null || true
  echo "→ Removing worktree..."
  git worktree remove --force "$WORKTREE_DIR"
  echo "→ Deleting branch '$WT_BRANCH'..."
  git branch -d "$WT_BRANCH" 2>/dev/null || true

  echo "✓ Done"
  exit 0
fi

SETUP_LOG=$(mktemp)

# Create the worktree — new branch from dev first, fall back to existing branch
echo "Creating worktree at $WORKTREE_DIR..."
if ! git worktree add -b "$BRANCH" "$WORKTREE_DIR" dev 2>/dev/null; then
  if ! git worktree add "$WORKTREE_DIR" "$BRANCH" 2>/dev/null; then
    echo "Error: could not create worktree. Is this branch already checked out?"
    exit 1
  fi
  echo "  Checked out existing branch '$BRANCH'"
else
  echo "  Created new branch '$BRANCH' from dev"
fi

# Run setup, capturing output while still printing it
echo ""
(cd "$WORKTREE_DIR" && bash worktree-setup.sh) 2>&1 | tee "$SETUP_LOG"

# Start the dev server in the background, capturing its output too
echo ""
echo "Starting dev server in background..."
rm -f "$WORKTREE_DIR/.dev-port"
(cd "$WORKTREE_DIR" && bash worktree-start.sh) 2>&1 | tee "$WORKTREE_DIR/.start-log" &

# Wait until the server signals it's ready
until [ -f "$WORKTREE_DIR/.dev-port" ]; do
  sleep 0.3
done
PORT=$(cat "$WORKTREE_DIR/.dev-port")
echo "Dev server ready — http://127.0.0.1:$PORT/"

# Build context to pass as the AI editor's initial message
CONTEXT="Worktree setup complete for branch '$BRANCH'.

Dev server is running at http://127.0.0.1:$PORT/
To sign in: navigate to /accounts/login/ and click 'Dev sign in (admin@admin.com)'.

=== Setup output ===
$(cat "$SETUP_LOG")

=== Server log ===
$(cat "$WORKTREE_DIR/.start-log")"

rm -f "$SETUP_LOG"

cd "$WORKTREE_DIR"

case "$MODE" in
  c)
    echo "Opening Claude Code (opus-4-6)..."
    exec claude --dangerously-skip-permissions --model claude-opus-4-6 "$CONTEXT"
    ;;
  o)
    echo "Opening Codex (gpt-codex-5.3)..."
    exec codex --model gpt-codex-5.3 "$CONTEXT"
    ;;
esac
